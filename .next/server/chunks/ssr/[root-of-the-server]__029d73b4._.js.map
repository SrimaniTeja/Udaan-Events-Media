{"version":3,"sources":["../../../../lib/db/prisma.ts","../../../../lib/workflow.ts","../../../../lib/db/store.ts","../../../../lib/db/mappers.ts","../../../../components/admin/CreateEventForm.tsx/__nextjs-internal-proxy.mjs","../../../../app/admin/events/new/page.tsx"],"sourcesContent":["import \"server-only\";\r\n\r\nimport { PrismaClient } from \"@prisma/client\";\r\n\r\nconst globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };\r\n\r\nexport const prisma =\r\n  globalForPrisma.prisma ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"warn\", \"error\"] : [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\r\n\r\n\r\n","import type { EventStatus, FileType, UserRole } from \"@/lib/types\";\r\n\r\nexport const EVENT_STATUSES: EventStatus[] = [\r\n  \"CREATED\",\r\n  \"RAW_UPLOADED\",\r\n  \"ASSIGNED\",\r\n  \"EDITING\",\r\n  \"FINAL_UPLOADED\",\r\n  \"COMPLETED\",\r\n];\r\n\r\nexport function canTransition(from: EventStatus, to: EventStatus) {\r\n  const allowed: Record<EventStatus, EventStatus[]> = {\r\n    CREATED: [\"RAW_UPLOADED\"],\r\n    RAW_UPLOADED: [\"ASSIGNED\"],\r\n    ASSIGNED: [\"EDITING\"],\r\n    EDITING: [\"FINAL_UPLOADED\"],\r\n    FINAL_UPLOADED: [\"COMPLETED\"],\r\n    COMPLETED: [],\r\n  };\r\n  return allowed[from].includes(to);\r\n}\r\n\r\nexport function canUploadFile(params: {\r\n  role: UserRole;\r\n  fileType: FileType;\r\n  status: EventStatus;\r\n}) {\r\n  const { role, fileType, status } = params;\r\n\r\n  if (role === \"CAMERAMAN\" && fileType === \"RAW\") return status === \"CREATED\";\r\n  if (role === \"EDITOR\" && fileType === \"FINAL\")\r\n    return status === \"EDITING\" || status === \"ASSIGNED\";\r\n\r\n  return false;\r\n}\r\n\r\nexport function canMarkWorkDone(role: UserRole, status: EventStatus) {\r\n  return role === \"CAMERAMAN\" && status === \"CREATED\";\r\n}\r\n\r\nexport function canStartEditing(role: UserRole, status: EventStatus) {\r\n  return role === \"EDITOR\" && status === \"ASSIGNED\";\r\n}\r\n\r\nexport function canMarkCompleted(role: UserRole, status: EventStatus) {\r\n  return role === \"EDITOR\" && status === \"FINAL_UPLOADED\";\r\n}\r\n\r\n\r\n","import \"server-only\";\r\n\r\nimport type { Event, EventStatus, FileType, MediaFile, SessionUser, User, UserRole } from \"@/lib/types\";\r\nimport type { Notification, NotificationType } from \"@/lib/notifications\";\r\nimport { prisma } from \"@/lib/db/prisma\";\r\nimport { canTransition } from \"@/lib/workflow\";\r\nimport { mapEvent, mapFile, mapNotification, mapSessionUser, mapUser } from \"@/lib/db/mappers\";\r\n\r\nexport async function listUsers(role?: UserRole): Promise<User[]> {\r\n  const users = await prisma.user.findMany({\r\n    where: role ? { role } : undefined,\r\n    orderBy: { createdAt: \"asc\" },\r\n  });\r\n  return users.map(mapUser);\r\n}\r\n\r\nexport async function findUserByEmail(email: string): Promise<User | null> {\r\n  const user = await prisma.user.findUnique({ where: { email: email.toLowerCase() } });\r\n  return user ? mapUser(user) : null;\r\n}\r\n\r\nexport async function getDbUserByEmail(email: string) {\r\n  return prisma.user.findUnique({ where: { email: email.toLowerCase() } });\r\n}\r\n\r\nexport async function listEventsForUser(user: SessionUser): Promise<Event[]> {\r\n  const where =\r\n    user.role === \"ADMIN\"\r\n      ? {}\r\n      : user.role === \"CAMERAMAN\"\r\n        ? { cameramanId: user.id }\r\n        : { editorId: user.id };\r\n\r\n  const events = await prisma.event.findMany({ where, orderBy: { date: \"desc\" } });\r\n  return events.map(mapEvent);\r\n}\r\n\r\nexport async function getEventById(eventId: string): Promise<Event | null> {\r\n  const event = await prisma.event.findUnique({ where: { id: eventId } });\r\n  return event ? mapEvent(event) : null;\r\n}\r\n\r\nexport async function listFilesForEvent(eventId: string, fileType?: FileType): Promise<MediaFile[]> {\r\n  const files = await prisma.file.findMany({\r\n    where: { eventId, ...(fileType ? { fileType } : {}) },\r\n    orderBy: { createdAt: \"desc\" },\r\n  });\r\n  return files.map(mapFile);\r\n}\r\n\r\nexport async function getFileById(fileId: string): Promise<MediaFile | null> {\r\n  const f = await prisma.file.findUnique({ where: { id: fileId } });\r\n  return f ? mapFile(f) : null;\r\n}\r\n\r\nexport async function createEvent(input: {\r\n  name: string;\r\n  date: string;\r\n  cameramanId: string;\r\n  editorId: string | null;\r\n}): Promise<Event> {\r\n  const event = await prisma.event.create({\r\n    data: {\r\n      name: input.name,\r\n      date: new Date(input.date),\r\n      cameramanId: input.cameramanId,\r\n      editorId: input.editorId ?? null,\r\n      status: \"CREATED\",\r\n    },\r\n  });\r\n  return mapEvent(event);\r\n}\r\n\r\nexport async function transitionEvent(eventId: string, nextStatus: EventStatus): Promise<Event | null> {\r\n  return prisma.$transaction(async (tx: any) => {\r\n    const event = await tx.event.findUnique({ where: { id: eventId } });\r\n    if (!event) return null;\r\n\r\n    if (!canTransition(event.status as any, nextStatus)) {\r\n      throw new Error(`Invalid status transition: ${event.status} -> ${nextStatus}`);\r\n    }\r\n\r\n    const updated = await tx.event.update({\r\n      where: { id: eventId },\r\n      data: { status: nextStatus },\r\n    });\r\n    return mapEvent(updated);\r\n  });\r\n}\r\n\r\nexport async function setEditorFree(editorId: string, isFree: boolean): Promise<User> {\r\n  const u = await prisma.user.update({\r\n    where: { id: editorId },\r\n    data: { isFree },\r\n  });\r\n  return mapUser(u);\r\n}\r\n\r\nexport async function setEditor(eventId: string, editorId: string | null): Promise<Event> {\r\n  const event = await prisma.event.update({\r\n    where: { id: eventId },\r\n    data: { editorId },\r\n  });\r\n  return mapEvent(event);\r\n}\r\n\r\nexport async function autoAssignFreeEditor(eventId: string): Promise<Event | null> {\r\n  return prisma.$transaction(async (tx: any) => {\r\n    const event = await tx.event.findUnique({ where: { id: eventId } });\r\n    if (!event) return null;\r\n    if (event.editorId) return mapEvent(event);\r\n\r\n    const freeEditor = await tx.user.findFirst({\r\n      where: { role: \"EDITOR\", isFree: true },\r\n      orderBy: { createdAt: \"asc\" },\r\n    });\r\n    if (!freeEditor) return mapEvent(event);\r\n\r\n    await tx.user.update({ where: { id: freeEditor.id }, data: { isFree: false } });\r\n    const updated = await tx.event.update({\r\n      where: { id: eventId },\r\n      data: { editorId: freeEditor.id },\r\n    });\r\n    return mapEvent(updated);\r\n  });\r\n}\r\n\r\nexport async function addFile(params: {\r\n  eventId: string;\r\n  uploadedBy: string;\r\n  fileType: FileType;\r\n  name: string;\r\n  size: number;\r\n}): Promise<MediaFile> {\r\n  const f = await prisma.file.create({\r\n    data: {\r\n      eventId: params.eventId,\r\n      uploaderId: params.uploadedBy,\r\n      fileType: params.fileType,\r\n      name: params.name,\r\n      size: params.size,\r\n      driveFileId: null,\r\n    },\r\n  });\r\n  return mapFile(f);\r\n}\r\n\r\nexport async function createNotification(params: {\r\n  userId: string;\r\n  title: string;\r\n  message: string;\r\n  type: NotificationType;\r\n  eventId?: string;\r\n}): Promise<Notification> {\r\n  const n = await prisma.notification.create({\r\n    data: {\r\n      userId: params.userId,\r\n      eventId: params.eventId,\r\n      title: params.title,\r\n      message: params.message,\r\n      type: params.type,\r\n    },\r\n  });\r\n  return mapNotification(n);\r\n}\r\n\r\nexport async function listNotificationsForUser(userId: string): Promise<Notification[]> {\r\n  const notifications = await prisma.notification.findMany({\r\n    where: { userId },\r\n    orderBy: { createdAt: \"desc\" },\r\n  });\r\n  return notifications.map(mapNotification);\r\n}\r\n\r\nexport async function markNotificationRead(notificationId: string, userId: string): Promise<Notification | null> {\r\n  const existing = await prisma.notification.findUnique({ where: { id: notificationId } });\r\n  if (!existing || existing.userId !== userId) return null;\r\n\r\n  const updated = await prisma.notification.update({\r\n    where: { id: notificationId },\r\n    data: { isRead: true },\r\n  });\r\n  return mapNotification(updated);\r\n}\r\n\r\nexport async function getSessionUserFromDb(userId: string) {\r\n  const u = await prisma.user.findUnique({ where: { id: userId } });\r\n  return u ? mapSessionUser(u) : null;\r\n}\r\n\r\n\r\n","import type { Event, MediaFile, SessionUser, User } from \"@/lib/types\";\r\nimport type { Notification as UiNotification } from \"@/lib/notifications\";\r\n\r\n// Minimal DB record shapes (keeps typing stable even if tooling can't resolve Prisma model type exports).\r\ntype DbUser = {\r\n  id: string;\r\n  name: string;\r\n  email: string;\r\n  passwordHash: string;\r\n  role: string;\r\n  isFree: boolean;\r\n};\r\n\r\ntype DbEvent = {\r\n  id: string;\r\n  name: string;\r\n  date: Date;\r\n  cameramanId: string;\r\n  editorId: string | null;\r\n  status: string;\r\n  driveRootId: string | null;\r\n  driveRawId: string | null;\r\n  driveEditedId: string | null;\r\n  driveFinalId: string | null;\r\n};\r\n\r\ntype DbFile = {\r\n  id: string;\r\n  eventId: string;\r\n  uploaderId: string;\r\n  fileType: string;\r\n  driveFileId: string | null;\r\n  size: number;\r\n  createdAt: Date;\r\n  name: string;\r\n};\r\n\r\ntype DbNotification = {\r\n  id: string;\r\n  userId: string;\r\n  eventId: string | null;\r\n  title: string;\r\n  message: string;\r\n  type: string | null;\r\n  isRead: boolean;\r\n  createdAt: Date;\r\n};\r\n\r\nexport function mapUser(u: DbUser): User {\r\n  return {\r\n    id: u.id,\r\n    name: u.name,\r\n    email: u.email,\r\n    role: u.role as User[\"role\"],\r\n    isFree: u.role === \"EDITOR\" ? u.isFree : undefined,\r\n  };\r\n}\r\n\r\nexport function mapSessionUser(u: DbUser): SessionUser {\r\n  return { id: u.id, name: u.name, email: u.email, role: u.role as SessionUser[\"role\"] };\r\n}\r\n\r\nexport function mapEvent(e: DbEvent): Event {\r\n  return {\r\n    id: e.id,\r\n    name: e.name,\r\n    date: e.date.toISOString(),\r\n    cameramanId: e.cameramanId ?? null,\r\n    editorId: e.editorId ?? null,\r\n    status: e.status as Event[\"status\"],\r\n    driveFolderId_root: e.driveRootId ?? null,\r\n    driveFolderId_raw: e.driveRawId ?? null,\r\n    driveFolderId_edited: e.driveEditedId ?? null,\r\n    driveFolderId_final: e.driveFinalId ?? null,\r\n  };\r\n}\r\n\r\nexport function mapFile(f: DbFile): MediaFile {\r\n  return {\r\n    id: f.id,\r\n    eventId: f.eventId,\r\n    uploadedBy: f.uploaderId,\r\n    fileType: f.fileType as MediaFile[\"fileType\"],\r\n    driveFileId: f.driveFileId ?? \"\",\r\n    size: f.size,\r\n    timestamp: f.createdAt.toISOString(),\r\n    name: f.name,\r\n  };\r\n}\r\n\r\nexport function mapNotification(n: DbNotification): UiNotification {\r\n  return {\r\n    id: n.id,\r\n    userId: n.userId,\r\n    eventId: n.eventId ?? undefined,\r\n    title: n.title,\r\n    message: n.message,\r\n    isRead: n.isRead,\r\n    type: (n.type ?? \"EVENT_ASSIGNED\") as UiNotification[\"type\"],\r\n    createdAt: n.createdAt.toISOString(),\r\n  };\r\n}\r\n\r\n\r\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const CreateEventForm = registerClientReference(\n    function() { throw new Error(\"Attempted to call CreateEventForm() from the server but CreateEventForm is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/admin/CreateEventForm.tsx\",\n    \"CreateEventForm\",\n);\n","import { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/Card\";\r\nimport { requireRole } from \"@/lib/auth/requireRole\";\r\nimport { listUsers } from \"@/lib/db/store\";\r\nimport { CreateEventForm } from \"@/components/admin/CreateEventForm\";\r\n\r\nexport default async function AdminCreateEventPage() {\r\n  await requireRole(\"ADMIN\");\r\n  const cameramen = await listUsers(\"CAMERAMAN\");\r\n  const editors = await listUsers(\"EDITOR\");\r\n\r\n  return (\r\n    <div className=\"grid gap-6\">\r\n      <div>\r\n        <div className=\"text-lg font-semibold\">Create Event</div>\r\n        <div className=\"mt-1 text-sm text-muted-foreground\">\r\n          This will later create Google Drive folders automatically (RAW / EDITED / FINAL).\r\n        </div>\r\n      </div>\r\n\r\n      <Card className=\"max-w-2xl\">\r\n        <CardHeader>\r\n          <CardTitle>Event details</CardTitle>\r\n          <CardDescription>Assign cameraman and editor (optional for now).</CardDescription>\r\n        </CardHeader>\r\n        <CardContent>\r\n          <CreateEventForm cameramen={cameramen} editors={editors} />\r\n        </CardContent>\r\n      </Card>\r\n    </div>\r\n  );\r\n}\r\n\r\n\r\n"],"names":[],"mappings":"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","ignoreList":[4]}